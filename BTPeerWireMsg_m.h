//
// Generated file, do not edit! Created by opp_msgc 4.2 from applications/BitTorrent/BTPeerWireMsg.msg.
//

#ifndef _BTPEERWIREMSG_M_H_
#define _BTPEERWIREMSG_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0402
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "../tcpapp/GenericAppMsg_m.h"
#include "BTTrackerMsg_m.h"
// }}



/**
 * Enum generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * enum PeerWireMsgIDs
 * {
 * 
 *     CHOKE = 0;
 *     UNCHOKE = 1;
 *     INTERESTED = 2;
 *     NOT_INTERESTED = 3;
 *     HAVE = 4;
 *     BITFIELD = 5;
 *     REQUEST = 6;
 *     PIECE = 7;
 *     CANCEL = 8;
 * }
 * </pre>
 */
enum PeerWireMsgIDs {
    CHOKE = 0,
    UNCHOKE = 1,
    INTERESTED = 2,
    NOT_INTERESTED = 3,
    HAVE = 4,
    BITFIELD = 5,
    REQUEST = 6,
    PIECE = 7,
    CANCEL = 8
};

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTMsgHandshake extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     char pstrlen;		
 *     string pstr;
 *     bool reserved[8];
 *     string infoHash;
 *     string peerId;
 * 
 * }
 * </pre>
 */
class BTMsgHandshake : public ::GenericAppMsg
{
  protected:
    char pstrlen_var;
    opp_string pstr_var;
    bool reserved_var[8];
    opp_string infoHash_var;
    opp_string peerId_var;

  private:
    void copy(const BTMsgHandshake& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTMsgHandshake&);

  public:
    BTMsgHandshake(const char *name=NULL, int kind=0);
    BTMsgHandshake(const BTMsgHandshake& other);
    virtual ~BTMsgHandshake();
    BTMsgHandshake& operator=(const BTMsgHandshake& other);
    virtual BTMsgHandshake *dup() const {return new BTMsgHandshake(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual char pstrlen() const;
    virtual void setPstrlen(char pstrlen);
    virtual const char * pstr() const;
    virtual void setPstr(const char * pstr);
    virtual unsigned int reservedArraySize() const;
    virtual bool reserved(unsigned int k) const;
    virtual void setReserved(unsigned int k, bool reserved);
    virtual const char * infoHash() const;
    virtual void setInfoHash(const char * infoHash);
    virtual const char * peerId() const;
    virtual void setPeerId(const char * peerId);
};

inline void doPacking(cCommBuffer *b, BTMsgHandshake& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTMsgHandshake& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTKeepAliveMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 * }
 * </pre>
 */
class BTKeepAliveMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;

  private:
    void copy(const BTKeepAliveMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTKeepAliveMsg&);

  public:
    BTKeepAliveMsg(const char *name=NULL, int kind=0);
    BTKeepAliveMsg(const BTKeepAliveMsg& other);
    virtual ~BTKeepAliveMsg();
    BTKeepAliveMsg& operator=(const BTKeepAliveMsg& other);
    virtual BTKeepAliveMsg *dup() const {return new BTKeepAliveMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
};

inline void doPacking(cCommBuffer *b, BTKeepAliveMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTKeepAliveMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTPeerStateMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 *     unsigned short ID @enum(PeerWireMsgIDs);
 * }
 * </pre>
 */
class BTPeerStateMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;
    unsigned short ID_var;

  private:
    void copy(const BTPeerStateMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTPeerStateMsg&);

  public:
    BTPeerStateMsg(const char *name=NULL, int kind=0);
    BTPeerStateMsg(const BTPeerStateMsg& other);
    virtual ~BTPeerStateMsg();
    BTPeerStateMsg& operator=(const BTPeerStateMsg& other);
    virtual BTPeerStateMsg *dup() const {return new BTPeerStateMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
    virtual unsigned short ID() const;
    virtual void setID(unsigned short ID);
};

inline void doPacking(cCommBuffer *b, BTPeerStateMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTPeerStateMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTHaveMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 *     unsigned short ID @enum(PeerWireMsgIDs);
 *     int index;
 * }
 * </pre>
 */
class BTHaveMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;
    unsigned short ID_var;
    int index_var;

  private:
    void copy(const BTHaveMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTHaveMsg&);

  public:
    BTHaveMsg(const char *name=NULL, int kind=0);
    BTHaveMsg(const BTHaveMsg& other);
    virtual ~BTHaveMsg();
    BTHaveMsg& operator=(const BTHaveMsg& other);
    virtual BTHaveMsg *dup() const {return new BTHaveMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
    virtual unsigned short ID() const;
    virtual void setID(unsigned short ID);
    virtual int index() const;
    virtual void setIndex(int index);
};

inline void doPacking(cCommBuffer *b, BTHaveMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTHaveMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTBitfieldMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 *     unsigned short ID @enum(PeerWireMsgIDs);
 *     bool bitfield[];
 * }
 * </pre>
 */
class BTBitfieldMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;
    unsigned short ID_var;
    bool *bitfield_var; // array ptr
    unsigned int bitfield_arraysize;

  private:
    void copy(const BTBitfieldMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTBitfieldMsg&);

  public:
    BTBitfieldMsg(const char *name=NULL, int kind=0);
    BTBitfieldMsg(const BTBitfieldMsg& other);
    virtual ~BTBitfieldMsg();
    BTBitfieldMsg& operator=(const BTBitfieldMsg& other);
    virtual BTBitfieldMsg *dup() const {return new BTBitfieldMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
    virtual unsigned short ID() const;
    virtual void setID(unsigned short ID);
    virtual void setBitfieldArraySize(unsigned int size);
    virtual unsigned int bitfieldArraySize() const;
    virtual bool bitfield(unsigned int k) const;
    virtual void setBitfield(unsigned int k, bool bitfield);
};

inline void doPacking(cCommBuffer *b, BTBitfieldMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTBitfieldMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTRequestCancelMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 *     unsigned short ID @enum(PeerWireMsgIDs);
 *     int index;
 *     int begin;
 *     int dataLength;
 *     bool endGame;
 * }
 * </pre>
 */
class BTRequestCancelMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;
    unsigned short ID_var;
    int index_var;
    int begin_var;
    int dataLength_var;
    bool endGame_var;

  private:
    void copy(const BTRequestCancelMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTRequestCancelMsg&);

  public:
    BTRequestCancelMsg(const char *name=NULL, int kind=0);
    BTRequestCancelMsg(const BTRequestCancelMsg& other);
    virtual ~BTRequestCancelMsg();
    BTRequestCancelMsg& operator=(const BTRequestCancelMsg& other);
    virtual BTRequestCancelMsg *dup() const {return new BTRequestCancelMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
    virtual unsigned short ID() const;
    virtual void setID(unsigned short ID);
    virtual int index() const;
    virtual void setIndex(int index);
    virtual int begin() const;
    virtual void setBegin(int begin);
    virtual int dataLength() const;
    virtual void setDataLength(int dataLength);
    virtual bool endGame() const;
    virtual void setEndGame(bool endGame);
};

inline void doPacking(cCommBuffer *b, BTRequestCancelMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTRequestCancelMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTPieceMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     int length_prefix;
 *     unsigned short ID @enum(PeerWireMsgIDs);
 *     int index;
 *     int begin;
 *     string data;
 * }
 * </pre>
 */
class BTPieceMsg : public ::GenericAppMsg
{
  protected:
    int length_prefix_var;
    unsigned short ID_var;
    int index_var;
    int begin_var;
    opp_string data_var;

  private:
    void copy(const BTPieceMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTPieceMsg&);

  public:
    BTPieceMsg(const char *name=NULL, int kind=0);
    BTPieceMsg(const BTPieceMsg& other);
    virtual ~BTPieceMsg();
    BTPieceMsg& operator=(const BTPieceMsg& other);
    virtual BTPieceMsg *dup() const {return new BTPieceMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int length_prefix() const;
    virtual void setLength_prefix(int length_prefix);
    virtual unsigned short ID() const;
    virtual void setID(unsigned short ID);
    virtual int index() const;
    virtual void setIndex(int index);
    virtual int begin() const;
    virtual void setBegin(int begin);
    virtual const char * data() const;
    virtual void setData(const char * data);
};

inline void doPacking(cCommBuffer *b, BTPieceMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTPieceMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTInternalMsg extends cMessage
 * {
 *     @omitGetVerb(true);
 * 
 *     string text;
 *     PEER peer;
 *     int pieceIndex;
 *     int blockIndex;
 *     bool chokedPiece;
 * }
 * </pre>
 */
class BTInternalMsg : public ::cMessage
{
  protected:
    opp_string text_var;
    PEER peer_var;
    int pieceIndex_var;
    int blockIndex_var;
    bool chokedPiece_var;

  private:
    void copy(const BTInternalMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTInternalMsg&);

  public:
    BTInternalMsg(const char *name=NULL, int kind=0);
    BTInternalMsg(const BTInternalMsg& other);
    virtual ~BTInternalMsg();
    BTInternalMsg& operator=(const BTInternalMsg& other);
    virtual BTInternalMsg *dup() const {return new BTInternalMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * text() const;
    virtual void setText(const char * text);
    virtual PEER& peer();
    virtual const PEER& peer() const {return const_cast<BTInternalMsg*>(this)->peer();}
    virtual void setPeer(const PEER& peer);
    virtual int pieceIndex() const;
    virtual void setPieceIndex(int pieceIndex);
    virtual int blockIndex() const;
    virtual void setBlockIndex(int blockIndex);
    virtual bool chokedPiece() const;
    virtual void setChokedPiece(bool chokedPiece);
};

inline void doPacking(cCommBuffer *b, BTInternalMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTInternalMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/BitTorrent/BTPeerWireMsg.msg</tt> by opp_msgc.
 * <pre>
 * message BTAcceptConnectionMsg extends GenericAppMsg
 * {
 *     @omitGetVerb(true);
 * 
 *     bool accept = true;
 * }
 * </pre>
 */
class BTAcceptConnectionMsg : public ::GenericAppMsg
{
  protected:
    bool accept_var;

  private:
    void copy(const BTAcceptConnectionMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BTAcceptConnectionMsg&);

  public:
    BTAcceptConnectionMsg(const char *name=NULL, int kind=0);
    BTAcceptConnectionMsg(const BTAcceptConnectionMsg& other);
    virtual ~BTAcceptConnectionMsg();
    BTAcceptConnectionMsg& operator=(const BTAcceptConnectionMsg& other);
    virtual BTAcceptConnectionMsg *dup() const {return new BTAcceptConnectionMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool accept() const;
    virtual void setAccept(bool accept);
};

inline void doPacking(cCommBuffer *b, BTAcceptConnectionMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BTAcceptConnectionMsg& obj) {obj.parsimUnpack(b);}


#endif // _BTPEERWIREMSG_M_H_
